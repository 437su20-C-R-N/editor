tinymce.PluginManager.add('gapfill', function(editor) {

    function gapfillHTML(n) {
        return '<gapfill class="mceNonEditable">Gap <span class="gap-number">'+n+'</span></gapfill>'
    }
    function gapfillText(n) {
        return '[['+n+']]';
    }

    editor.replaceGapfills = function(content) {
        return content.replace(/\[\[(\d+)\]\]/g,function(m,n) {
            return gapfillHTML(n);
        });
    }
    editor.restoreGapfills = function(content) {
        return content.replace(/<gapfill class="mceNonEditable">Gap <span class="gap-number">(\d+)<\/span><\/gapfill>/g,function(t,n) {
            return gapfillText(n);
        });
    }

    editor.on('BeforeSetcontent', function(evt){ 
        evt.content = editor.replaceGapfills( evt.content );
    });

    editor.on('GetContent', function(evt){
        if(!evt.keepGapfills) {
            evt.content = editor.restoreGapfills(evt.content);
        }
    });

    function promptGapNumber(callback,value) {
        editor.windowManager.open({
            title: 'Gapfill',
            body: [
                {type: 'textbox', subtype: 'number', name: 'n', label: 'Number of gap', value: value}
            ],
            onsubmit: function(e) {
                var n = e.data.n;
                if(!isNaN(n)) {
                    n = parseInt(n);
                    callback(n);
                }
            }
        });
    }

    function insertGapfill(ui,val) {
        var gaps = editor.dom.select('gapfill .gap-number');
        var max = null;
        var ns = [];
        gaps.map(function(g) {
            var n = parseInt(g.textContent);
            ns.push(n);
        });
        var max = 0;
        ns.sort();
        ns.forEach(function(n) {
            if(n==max) {
                max += 1;
            }
        });
        promptGapNumber(function(n) {
            editor.execCommand('mceInsertContent',true,gapfillHTML(n));
        },max+'');
    }

    function changeGapfill(node) {
        promptGapNumber(function(n) {
            node.querySelector('.gap-number').textContent = n;
        },node.querySelector('.gap-number').textContent);
    }

    editor.addMenuItem('gapfill', {
        shortcut: 'Alt+G',
        text: 'Insert gap',
        onclick: insertGapfill,
        context: 'insert',
        prependToContext: true,
        onpostrender: function() {
            var menu_item = this;
            editor.on('toggle_gapfill_button',function(e) {
                menu_item.disabled(!e.show);
            });
        }
    });

    editor.addButton('gapfill', {
        shortcut: 'Alt+G',
        classes: 'widget btn gapfill',
        text: 'G',
        tooltip: 'Insert gap',
        onclick: insertGapfill,
        onpostrender: function() {
            var btn = this;
            editor.on('toggle_gapfill_button',function(e) {
                btn.disabled(!e.show);
            });
        }
    });

    editor.addShortcut('Alt+G','Insert gap',insertGapfill);

    editor.addCommand('insertGapfill', insertGapfill);

    editor.on('DblClick',function(e) {
        if(e.target.nodeName.toLowerCase()=='gapfill') {
            changeGapfill(e.target);
        }
    });
});
